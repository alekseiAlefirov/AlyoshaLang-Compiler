// Signature file for parser generated by fsyacc
module AlyoshaParser
type token = 
  | EOF
  | AND
  | OR
  | MATCH
  | WITH
  | ENDMATCH
  | FUN
  | FUNARROW
  | NUF
  | READNUM
  | READLINE
  | WRITE
  | WHILE
  | DO
  | OD
  | IF
  | THEN
  | ELSE
  | ELIF
  | FI
  | SEMICOLON
  | COLON
  | PLUS
  | MINUS
  | MUL
  | DIV
  | MOD
  | OF
  | UNION
  | ISEQUAL
  | NOTEQUAL
  | GREATER
  | NOTLESS
  | LESS
  | NOTGREATER
  | NOT
  | EQUAL
  | LET
  | REC
  | ANDREC
  | LPAREN
  | RPAREN
  | LBRACE
  | RBRACE
  | PIPE
  | PROGRAM
  | ID of (string)
  | UNIT
  | STRINGVAL of (string)
  | BOOLVAL of (bool)
  | NUMVAL of (System.Int32)
type tokenId = 
    | TOKEN_EOF
    | TOKEN_AND
    | TOKEN_OR
    | TOKEN_MATCH
    | TOKEN_WITH
    | TOKEN_ENDMATCH
    | TOKEN_FUN
    | TOKEN_FUNARROW
    | TOKEN_NUF
    | TOKEN_READNUM
    | TOKEN_READLINE
    | TOKEN_WRITE
    | TOKEN_WHILE
    | TOKEN_DO
    | TOKEN_OD
    | TOKEN_IF
    | TOKEN_THEN
    | TOKEN_ELSE
    | TOKEN_ELIF
    | TOKEN_FI
    | TOKEN_SEMICOLON
    | TOKEN_COLON
    | TOKEN_PLUS
    | TOKEN_MINUS
    | TOKEN_MUL
    | TOKEN_DIV
    | TOKEN_MOD
    | TOKEN_OF
    | TOKEN_UNION
    | TOKEN_ISEQUAL
    | TOKEN_NOTEQUAL
    | TOKEN_GREATER
    | TOKEN_NOTLESS
    | TOKEN_LESS
    | TOKEN_NOTGREATER
    | TOKEN_NOT
    | TOKEN_EQUAL
    | TOKEN_LET
    | TOKEN_REC
    | TOKEN_ANDREC
    | TOKEN_LPAREN
    | TOKEN_RPAREN
    | TOKEN_LBRACE
    | TOKEN_RBRACE
    | TOKEN_PIPE
    | TOKEN_PROGRAM
    | TOKEN_ID
    | TOKEN_UNIT
    | TOKEN_STRINGVAL
    | TOKEN_BOOLVAL
    | TOKEN_NUMVAL
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start
    | NONTERM_Prog
    | NONTERM_UnionBlock
    | NONTERM_UnionDef
    | NONTERM_TypeVariables
    | NONTERM_UnionElementList
    | NONTERM_UnionElement
    | NONTERM_TypeCortage
    | NONTERM_Block
    | NONTERM_Statement
    | NONTERM_AssignmentAtom
    | NONTERM_Assignment
    | NONTERM_LetAssignment
    | NONTERM_LetRecursiveAssignment
    | NONTERM_RecAndList
    | NONTERM_IfStatement
    | NONTERM_ElifList
    | NONTERM_WhileStatement
    | NONTERM_WriteStatement
    | NONTERM_MatchStatement
    | NONTERM_GuardList
    | NONTERM_Guard
    | NONTERM_GuardArgs
    | NONTERM_Expression
    | NONTERM_RightLogicTermList
    | NONTERM_Application
    | NONTERM_LeftAppPart
    | NONTERM_ApplicantsList
    | NONTERM_Abstraction
    | NONTERM_FunArguments
    | NONTERM_IdList
    | NONTERM_LogicTerm
    | NONTERM_RightLogicFactorList
    | NONTERM_LogicFactor
    | NONTERM_CompOp
    | NONTERM_ArithmeticOp
    | NONTERM_RightTermList
    | NONTERM_ArithmeticOpSign
    | NONTERM_Term
    | NONTERM_RightFactorList
    | NONTERM_FactorOpSign
    | NONTERM_Factor
    | NONTERM_ModFactor
    | NONTERM_SimpleFactor
    | NONTERM_SimpleValue
    | NONTERM_Id
/// This function maps integers indexes to symbolic token ids
val tagOfToken: token -> int

/// This function maps integers indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val start : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> ( AlyoshaAST.program ) 
